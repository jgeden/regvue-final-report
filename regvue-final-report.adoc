= Improving Hardware Register Documentation Tooling
Josh Geden <joshua.geden@duke.edu>; Rob Donnelly <robert.donnelly@jpl.nasa.gov>
:toc:
:imagesdir: images
:sectnums:
:toclevels: 3
// :titlepage:
// :doctype: book
// :chapter-label:
// :hardbreaks-option:

== Abstract

Hardware documentation at JPL has historically been generated by hand and accessed through shared PDF or Word documents.
This can lead to issues where the documentation does not keep pace with the actual hardware implementation.
It also leads to documents that are difficult to use and lack the necessary features to accelerate the hardware debugging process.
To address these issues, a hardware documentation tool called _regvue_ was created.
This tool is available as both a web and desktop application and is capable of building advanced documentation sites from data files that implement the Register Description Format.
Documentation can now be automatically updated by making changes to the data files, ensuring that engineers always have access to current information in an easy-to-read format.
Features such as full-text search and automatic bit encoding/decoding are also provided.
Future features will include enabling _regvue_ to interface with hardware and directly read and decode register values.
By providing higher quality documentation and advanced features with _regvue_, hardware engineers will spend significantly less time during the debugging process.


== Introduction

When engineers need to consult Field Programmable Gate Array (FPGA) hardware documentation, they traditionally have turned to PDF or Word documents created and maintained by FPGA design engineers that are hosted on internal file-sharing websites.
From these websites, FPGA hardware test engineers can either preview the document online or they can download the file and open it locally.
Because online file viewers lack certain features and are typically slower to use, most engineers download these documentation files and use them locally.

This creates an issue when the design engineer uploads a new version of the documentation but test engineers continue to use their locally-downloaded documentation file, which has since become outdated.
This mismatch can be difficult to notice and can incur significant delays, and therefore additional costs, during the FPGA testing and debugging process.

In addition to this, the documentation provided by these documents is static and does not support the actual testing and debugging workflow of hardware engineers.
For example, say there is a field that takes up the bottom (least-significant) 6 bits of a 32 bit register.
This field represents the number of errors a certain device encounters.
A typical workflow to obtain the number of errors may therefore look like:

. Read out the value of the register using external tools as a big-endian hexadecimal value

. Convert the big-endian value to a little-endian value

. Convert that value from hexadecimal to binary

. Isolate the bottom 6 bits of that binary value

. Convert that value to decimal

/ Use a graphic to summarize these steps instead of writing out like this /

This manual manipulation and conversion of register and field values is incredibly error-prone and unnecessarily increases the complexity of the already complex hardware testing and debugging process.

These issues with JPL's existing hardware documentation strategy is what inspired the development of _regvue_.
Available as both a web and desktop application, _regvue_ utilizes a design-agnostic JSON schema called the Register Description Format (RDF) to generate easy-to-use modern documentation.

Design engineers can manually create RDF files or use existing register automation tools to generate RDF files from existing documentation specifications. 
_regvue_ can then parse these files to produce a website with all the features of classic online technical documentation sites as well as additional features specific to the FPGA testing and debugging workflow.

FPGA hardware test engineers no longer have to worry about accessing out-of-date documentation, because FPGA design engineers can host their RDF files through online repositories that _regvue_ can access, so any update to the design can be automatically reflected in the documentation site accessed by test engineers.
Test engineers also no longer have to manually parse register values, because _regvue_ includes an interactive bit table for every register that can automatically decode register values into meaningful representations and can automatically convert values between hexadecimal, decimal, and binary representations. The documentation provided by _regvue_ will therefore significantly reduces the costs and delays associated with testing and debugging FPGA hardware.

== Methods (Implementation)

This section details the different parts of the _regvue_ application and the surrounding technologies necessary to run and access it.

=== Schema

_regvue_ expands upon previous work that resulted in the creation of the Register Description Format (RDF) schema.
The RDF provides a design-agnostic JSON-encoded hardware design formalization that can be used to document FPGA hardware systems.

On different projects and missions, FPGA design engineers make use of different file formats and file types, such as Word DOCX files or Tcl files, when documenting their designs.
The RDF was created to bridge the gap between these different formats and file types and provide a general-use data format that can be used by external applications.
Different register automation solutions were then created that are capable of generating RDF files from the different hardware documentation types.

All RDF files begin as JSON-encoded files with three top-level objects.

The `schema` object defines the name and version of the schema being used.
_regvue_ currently only supports v1.x of the `register-description-format`, but this meta data was included to allow for future data formats to be supported in the future.
[source.json]
.Example `schema` object
----
"schema": {
    "version": "v1",
    "name": "register-description-format"
}
----

The `root` object provides information about the overall FPGA design being represented.
This includes the name, version, and descriptive doc text. 
It also includes a list of ids for all root-level elements (or root "children").
[source.json]
.Example `root` object
----
"root": {
    "version": "v1.0",
    "desc": "Example Design",
    "doc": "This is an example design.",
    "children": [ ... ],
}
----

The `elements` object is a map of all element within the system.
[source.json]
.Example `elements` object with a single `reg` type element
----
"elements": { 
    "registerA": {
        "id": "registerA",
        "name": "registerA",
        "type": "reg",
        "offset": "0x0",
        "doc": "Register A - an example register",
        "fields": [
            {
                "name": "example_field",
                "access": "ro",
                "lsb": 0,
                "nbits": 32,
                "doc": "Example field"
            }
        ]
    }
}
----

Because the RDF is designed to be used by external applications, it strictly adheres to https://semver.org/[semantic versioning] to ensure version compatibility.

/ Talk about JSON schema and schema validation /

=== Application

When developing _regvue_, the two highest priority goals were interactivity and portability.

There were already existing solutions in the form of Word documents and static auto-generated HTML pages, but these solutions lack interactivity. Word document specifications also lack portability between different operating systems.

We considered creating a desktop app with Python and the TK GUI library.
This would have been a portable solution, but more difficultly so, because there would be overhead in terms of users having to install Python to run the application.
It also makes updating _regvue_ much more complex because users would be running local executables.

Based on the shortcomings of these implementations, we decided to create _regvue_ as a web application.
This allows us to include interactivity by using JavaScript within the app and it is incredibly portable because users can access it from any browser on any type of OS.

==== Frontend

In order to build the frontend user interface (UI) of _regvue_ (everything that the user can see and interact with), we used the Vue framework with Typescript.

Using a framework like simplifies developing a web application.
It provides a declarative model, meaning when the state of the website changes, such as when a user clicks on a button or inputs a value in a text box, the UI automatically updates to match the new state.
It also provides a component model, meaning sections of code can be encapsulated in modular components that can be reused multiple times throughout the application.

Similar frontend frameworks, such as Angular or React, also could have been used to create _regvue_.
We made the decision to use Vue because of its use of native HTML templates to build UIs (as compared to React's use of JSX) and because Vue follows a progressive development model (as compared to Angular's more opinionated MVC-based design).

We also used Typescript instead of plain JavaScript to improve the ease of development and maintainability of the code base.
Typescript allows the project to have well defined type interfaces that improve code readability and will make returning to the source code easier in the future.

_regvue_ uses Tailwind CSS, a utility-first CSS framework, that provides composable CSS classes to functionally build modern styles.
Originally, _regvue_ was built using pre-stylized components from the PrimeVue component library.
PrimeVue provides pre-made components that can be used to quickly build a web app, but developers then are not able to customize the styling very easily.
PrimeVue also includes a large amount of overhead.

/ Removed PrimeVue. Why? /

==== Search

/ Talk about search /

/ Client-side with Lunr /

/ Issues /

==== Bit Manipulation

/ Bit table /

/ Swap between representations /

/ Byte swap /

/ Resets /

/ Enums /

==== Routing

_regvue_ uses Vue Router to handle URL navigation.
As a progressive framework, Vue allows developers to opt-in to different levels of complexity, and therefore does not provide a router out of the box, however adding Vue Router to an existing project is incredibly simple since it follows a plugin-style architecture.

When the app first loads, a router object is created that comes with a predefined set of routes to handle.
_regvue_ currently has three distinct page views that the router can display based on the URL.

The first page view that most users of _regvue_ will see is the open page.
This page corresponds to the `/open` URL and provides users with input boxes to load a RDF file from the local filesystem or from a URL.

/ OpenView image /

Once the user opens a RDF file, the element page is shown.
This is the main view of _regvue_ and displays the documentation information about the different design elements.
It also includes the navigation menu and the header.

/ Talk about url pattern here and how it corresponds to element id /

/ ElementView image /

The final page view is the 404 page.
This view is displayed when a user either enters a URL that does not correspond to a pre-defined route or tries to navigate to an element that does not exist.

/ PageNotFound image /

==== Data Store

_regvue_ uses Pinia, a store library specifically designed for use with Vue, to store and maintain all cross-component data that is used in the app.
Normally, data within Vue apps must be directly passed from parent components to child components, but having data that is accessible throughout the entire app can help simplify this data hierarchy.

When _regvue_ first loads, a Pinia store object is created.
When the user then opens an RDF file, the store object parses the raw JSON and generates a map that stores all hardware elements (i.e. registers, blocks, or memory segments) within the given FPGA design as formatted Typescript objects.
This greatly simplifies accessing information about different elements from the different components within the file.
Instead of passing information about all the different elements from every parent component to every child component, _regvue_ can instead obtain the current element's id from the URL, and then can use that id to access information about the element from the store object.

==== Includes

/ Talk about using includes to build composed designs /

==== Testing

_regvue_ uses the Vitest unit testing framework to test utility functions and the Cypress end-to-end testing framework to perform browser-based integration testing.
These tests help ensure any changes to the code base do not break existing functionality. 

=== Deployment

_regvue_ has minimal hosting requirements and can be deployed as a static site on almost any hosting platform such as Vercel, Netlify, or AWS.
The _regvue_ development team maintains a set of deployments using GitHub Pages that correspond to all major versions of _regvue_, meaning end users do not need to install or deploy _regvue_ if they do not wish to.

==== Export Control

/ Talk about export control /

"Public repos on github.jpl.nasa.gov are limited to US persons.  This is good enough for Export Controlled information.  However, we have additional sensitivity levels that require further restriction (see D-77806).  For example, Controlled Unclassified (CUI)/Sensitive But Unclassified (SBU)/For Official Use Only (FOUO) must be restricted to select individuals.  This can be done by making the repo private then granting access to select individuals.  Would be good to include these designations in the report because these are NASA/government level designations (i.e. bigger than JPL)."
-- Rob

==== Authentication

Because _regvue_ is being used by JPL engineers to document information that more often than not is subject to U.S. Export Regulations, significant thought had to be given to ensure that only authorized users can access export-controlled information.
The _regvue_ application itself does not include any export-controlled information within its deployed build code, so the problem that we had to solve was finding a way to ensure any RDF files that users want to link to are limited to authenticated users but still accessible by the _regvue_ app.

Our use of GitHub Pages actually solved this issue for us with minimal overhead.
We host _regvue_ on JPL's GitHub Enterprise server using GitHub Pages, which is only accessible for authenticated users connected to the JPL VPN.
When users then want to access a RDF file by URL, if that file is also hosted on JPL's GitHub Enterprise server, no additional authentication is necessary because the _regvue_ deploy and the RDF file share the same origin URL.
This use of GitHub Enterprise therefore means the official _regvue_ deploy has built-in authentication with no additional code necessary.

==== Desktop Application

While _regvue_ was primarily developed to be deployed as a web app, we have also been able to create executable binaries that are capable of running directly on Windows, Mac, and Linux operating systems as a desktop application.
To accomplish this, we used the Tauri framework, which provides a Rust backend and a cross-platform WebView rendering library that is capable of displaying a web-based frontend.
While not officially supported yet, we plan to use these local executables in the future to add specific features to _regvue_ that would be otherwise impossible due to browser limitations.

== Results

Engineers working on the Europa Clipper and Mars Sample Return (MSR) missions have already integrated _regvue_ into their workflows, and so far the tool has proved to be a great help.

"I have used regvue a lot during integration testing for Europa Clipper.
There are integration tasks [where I have] to poke and peek at registers and the regvue tool allows me to quickly look up a register and test out different register values.
Figuring out those register values can be quite challenging since it is broken down to 32 bits, but the regvue tool helps make that translation easier.
It cuts down the time it would take to go through the document, put down on paper what the register should be and double checking the value.
Also, with the tool being able to convert from binary to decimal to hexadecimal, it makes translating engineering values way easier.
I hope to continue to use this on future projects such as MSR."
-- Brian Nguyen, Senior Electrical Engineer, Europa Clipper (348E) +

"Regvue is the interactive register viewer I have dreamed about for years.
It's a powerful tool to assist hardware designers, software designers, and end-users.
I plan to use it on all of my flight FPGA designs going forward"
-- Ryan Stern, MSR SRL Motor Control Card FPGA Task Lead (349C)

/ Talk more about how regvue has worked /

/ Talk about where does it fall short /

== Conclusion

Figures.
Include figures whenever possible to illustrate your points.
Explanatory diagrams may help explain background information (pictures from textbooks are fine).
Carefully choose your image size, font size, line widths, and labels to ensure that your figures are clear.
Plot theory and experiment on the same graph and redraw screen photos.
All figures should be accompanied by explanatory captions.

Favor fewer information packed screenshots that show multiple things at once.
Use annotations to point out relevant portions. (e.g. recent searches + search suggestions)
Consider creating an image that shows the link between the schema and the render (e.g.root.display_name and where it is rendered in the app)

== Acknowledgments

Special thanks to Rob Donnelly for his mentorship and guidance.
_regvue_ was his vision, and it has been an extremely rewarding experience helping to bring that vision to reality.

Thanks to Mike Thielman, <insert official title here> and the Europa Clipper Mission (MAKE THIS MORE SPECIFIC) for providing the funding and administrative support necessary to transform _regvue_ from a proposal and prototype to a full-fledged hardware documentation solution.

Additional thanks to Ryan Stern and the hardware engineers in the Flight Software and Avionics Systems Group for their early adoption of _regvue_ and for supporting its development by suggesting new features and identifying bugs.

And lastly, thanks to the Caltech Student-Faculty Programs Office and JPL for hosting the JPL Summer Internship Program and to all those who helped support this program.

== References

<add any references>