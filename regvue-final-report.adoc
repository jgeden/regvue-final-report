= Improving Hardware Register Documentation Tooling
Josh Geden <joshua.geden@duke.edu>; Rob Donnelly <robert.donnelly@jpl.nasa.gov>
:toc:
:imagesdir: images
:sectnums:
:toclevels: 3
:title-page:
:revdate: 2022-08-15
// :doctype: book
// :chapter-label:

== Abstract

Hardware documentation at JPL has historically been generated by hand and accessed through shared PDF or Word documents.
This can lead to issues where the documentation does not keep pace with the actual hardware implementation.
It also leads to documents that are difficult to use and lack the necessary features to accelerate the hardware debugging process.
To address these issues, a hardware documentation tool called _regvue_ was created.
This tool is available as both a web and desktop application and is capable of building advanced documentation sites from data files that implement the Register Description Format.
Documentation can now be automatically updated by making changes to the data files, ensuring that engineers always have access to current information in an easy-to-read format.
Features such as full-text search and automatic bit encoding/decoding are also provided.
Future features will include enabling _regvue_ to interface with hardware and directly read and decode register values.
By providing higher quality documentation and advanced features with _regvue_, hardware engineers will spend significantly less time during the debugging process.


== Introduction

When engineers need to consult Field Programmable Gate Array (FPGA) hardware documentation, they traditionally have turned to PDF or Word documents created and maintained by FPGA design engineers that are hosted on internal file-sharing websites.
From these websites, FPGA hardware test engineers can either preview the document online or they can download the file and open it locally.
Because online file viewers lack certain features and are typically slower to use, most engineers download these documentation files and use them locally.

This creates an issue when the design engineer uploads a new version of the documentation but test engineers continue to use their locally-downloaded documentation file, which has since become outdated.
This mismatch can be difficult to notice and can incur significant delays, and therefore additional costs, during the FPGA testing and debugging process.

In addition to this, the documentation provided by these documents is static and does not support the actual testing and debugging workflow of hardware engineers.
For example, say there is a field that takes up the bottom (least-significant) 6 bits of a 32 bit register.
This field represents the number of errors a certain device encounters.
A typical workflow to obtain the number of errors may therefore look like:

. Read out the value of the register using external tools as a big-endian hexadecimal value

. Convert the big-endian value to a little-endian value

. Convert that value from hexadecimal to binary

. Isolate the bottom 6 bits of that binary value

. Convert that value to decimal

This manual manipulation and conversion of register and field values is incredibly error-prone and unnecessarily increases the complexity of the already complex hardware testing and debugging process.

These issues with JPL's existing hardware documentation strategy is what inspired the development of _regvue_.
Available as both a web and desktop application, _regvue_ utilizes a design-agnostic JSON schema called the Register Description Format (RDF) to generate easy-to-use and modern hardware documentation.

Design engineers can manually create RDF files or use existing register automation tools to generate RDF files from existing documentation specifications. 
These files can then parsed by _regvue_ to produce a website with all the features of classic online technical documentation sites as well as additional features specific to the FPGA testing and debugging workflow.

FPGA hardware test engineers no longer have to worry about accessing out-of-date documentation, because FPGA design engineers can host their RDF files through online repositories that _regvue_ can access, so any update to the design can be automatically reflected in the documentation site accessed by test engineers.
Test engineers also no longer have to manually parse register values, because _regvue_ includes an interactive bit table for every register that can automatically decode register values into meaningful representations and can automatically convert values between hexadecimal, decimal, and binary representations. The documentation provided by _regvue_ will therefore significantly reduces the costs and delays associated with testing and debugging FPGA hardware.

== Methods (Implementation)

_regvue_ was developed by a small team of 2 developers.
New feature requests, potential bugs, and any discussion on design implementation was managed using GitHub Issues.
Any changes to the codebase were tracked and implemented incrementally using GitHub Pull Requests.

_regvue_ adheres to https://semver.org/[semantic versioning] to track the addition of new features and to introduce backwards-incompatible features or changes.
When _regvue_ reached a point where a new release was desired, first a GitHub Tag was created to mark the commit in the repository that the release corresponds to.
Then a compressed production bundle of the app would be published as a GitHub Release.
This Release would come with a summary of all the new changes as release notes.

After creating a new release, the official _regvue_ deployment maintained by the _regvue_ development team would be updated to this new version.

The following sections describe in a high-level manner the different aspects of the _regvue_ application and the surrounding technologies necessary to run it.
It will touch on the different problems encountered and how these problems were resolved.

=== Schema

_regvue_ expands upon previous work that resulted in the creation of the Register Description Format (RDF) schema.
The RDF provides a design-agnostic JSON-encoded hardware design formalization that can be used to document FPGA hardware systems.

On different projects and missions, FPGA design engineers make use of different file formats and file types, such as Word DOCX files or Tcl files, to document their designs.
The RDF was created to bridge the gap between these different formats and file types and to provide a general-use data format that can be used by external applications.
Different register automation solutions were then created that are capable of generating RDF files from the different types of hardware documentation specifications.

Because the RDF is designed to be used by external applications, it strictly adheres to https://semver.org/[semantic versioning] to ensure version compatibility.

All RDF files begin as JSON-encoded files with three top-level objects.

The `schema` object defines the name and version of the schema being used.
Only v1.x of the `register-description-format` is currently supported by _regvue_, but this meta data was included to allow for future data formats to be supported in the future.

[source.json]
.Example `schema` object
----
"schema": {
    "version": "v1",
    "name": "register-description-format"
}
----

The `root` object provides information about the overall FPGA design being represented.
This includes the name, version, and descriptive doc text. 
It also includes a list of ids for all root-level elements (or root "children").
[source.json]
.Example `root` object
----
"root": {
    "version": "v1.0",
    "desc": "Example Design",
    "doc": "This is an example design.",
    "children": [ ... ],
}
----

The `elements` object is a map of all element within the system.
[source.json]
.Example `elements` object with a single `reg` type element
----
"elements": { 
    "registerA": {
        "id": "registerA",
        "name": "registerA",
        "type": "reg",
        "offset": "0x0",
        "doc": "Register A - an example register",
        "fields": [
            {
                "name": "example_field",
                "access": "ro",
                "lsb": 0,
                "nbits": 32,
                "doc": "Example field"
            }
        ]
    }
}
----

The RDF uses a dot notation to manage element hierarchy.
If an element has the name `board` and its parent element is named `system` and has no parent element itself, then the `board` element has the id `system.board`.

In order to ensure any RDF files opened in _regvue_ conform to this schema, before a file is loaded it is validated using JSON Schema.
JSON Schema is a standardization that can be used to define what a JSON document must look like, ways to extract information from it, and how to interact with it.
Different validation libraries exist that support the JSON Schema standard and can be used to automatically validate that JSON files adhere to a specific schema.

=== Application

When developing _regvue_, the two highest priority goals were interactivity and portability.

There were already existing solutions in the form of Word documents and static auto-generated HTML pages, but these solutions lack interactivity. Word document specifications also lack portability between different operating systems.

We considered creating a desktop app with Python and the TK GUI library.
This would have been a portable solution, but more difficultly so, because there would be overhead in terms of users having to install Python to run the application.
It also makes updating _regvue_ much more complex because users would be running local executables.

Based on the shortcomings of these implementations, we decided to create _regvue_ as a web application.
This allows us to include interactivity by using JavaScript within the app and it is incredibly portable because users can access it from any browser on any type of OS.

==== Frontend

In order to build the frontend user interface (UI) of _regvue_ (everything that the user can see and interact with), we used the Vue framework with Typescript.

Using a framework like Vue simplifies the process of developing a web application.
It provides a declarative model, meaning when the state of the website changes, such as when a user clicks on a button or inputs a value in a text box, the UI automatically updates to match the new state.
It also provides a component model, meaning sections of code can be encapsulated in modular components that can be reused multiple times throughout the application.

Similar frontend frameworks, such as Angular or React, also could have been used to create _regvue_.
We made the decision to use Vue because of its use of native HTML templates to build UIs (as compared to React's use of JSX) and because Vue follows a progressive development model (as compared to Angular's more opinionated MVC-based design).

We also used Typescript instead of plain JavaScript to improve the ease of development and maintainability of the code base.
Typescript allows the project to have well defined type interfaces that improve code readability and will make returning to the source code easier in the future.

_regvue_ uses Tailwind CSS, a CSS utility framework that provides composable CSS classes to functionally build modern styles.
Originally, _regvue_ was built using pre-stylized components from the PrimeVue component library.
PrimeVue provides pre-made components that can be used to quickly build a web app, but at the cost of not being able to modify the styling of these components very easily.
Tailwind is also incredibly performant and will automatically remove unused CSS classes to ship the smallest possible CSS file, meaning it has a much lighter footprint than PrimeVue.

==== Bit Manipulation

One of the most pressing issues that _regvue_ was designed to resolve was to remove the need for hardware test engineers to manually manipulate register and field values.
To accomplish this, every register element shown in _regvue_ comes with an interactive bit table that provides a breakdown of the register value into its different fields.

This table includes a set of buttons that can be used to swap between binary, decimal, and hexadecimal representations.

It also includes a toggle button that will byte swap the register value.
This allows for big-endian values to be automatically converted to little-endian, and vice versa, before being broken apart in the different fields.

Registers can also come with different reset values, that are triggered by certain events, such when the device is powered on or when a hot reset is triggered.
The bit table provides a button and dropdown menu that provides options to select any reset state that a register is associated with.

Certain field values may correspond to named states.
For example, if an error field has a value of "0x1" that might correspond to an "Error" state.
The bit table supports enumerated field values and can automatically map these specific numeric values to named states.

/ Bit table image /

==== Search

FPGA designs can have over hundreds of hardware elements to document, so including extensive search functionality that can be used to quickly find elements was one of the first features to be added to _regvue_.

An important restriction on how we could implement search functionality was the need for export-controlled information to remain secure (see <<Export Control>> for more information).
This means we could not use popular search providers such as Elastic Search or Algolia, because they require transmitting the data to an external server.
These providers also usually charge for their services, and _regvue_ is committed to be accessible as free and open-source software.

For these reasons, we decided to implement a client-side search using the Lunr search library.
Lunr provides simple and extensible search functionality that has no external dependencies and can run completely within the browser, meaning no export-controlled information will ever be transmitted to an external service.

After users load a RDF file, a Lunr search index object is created that can be used to search for any hardware element by id, name, offset, or description text.
When the user provides a search query by typing in the search box, the index object will return a list of element ids that most closely correspond to the search text.

There are some drawbacks to using a client-side search.
There is additional load time necessary to build the search index on app load and it can take much more time to search the index with a given search query compared to external search providers.
However, because the data being searched is just plain text and FPGA designs would almost never have an element count in the thousands, the time to build the search index has an upper bound of just a couple seconds and to search the entire index typically takes less than 1 second for any query.

==== Routing

_regvue_ is implemented as a single-page application, and therefore needs to use a router to control which pages are displayed when users navigate to different URLs.

As a progressive framework, Vue allows developers to opt-in to different levels of complexity, and therefore does not provide a router out of the box.
However, the official Vue Router library is incredibly simple to add to an existing project since it follows a plugin-style architecture.

When the app first loads, a router object is created that comes with a predefined set of routes to handle.
_regvue_ currently has three distinct page views that the router can display based on the URL.

The first page view that most users of _regvue_ will see is the open page.
This page corresponds to the `/open` URL and provides users with input boxes to load a RDF file from the local filesystem or from a URL.

/ OpenView image /

Once the user opens a RDF file, the element page is shown.
This is the main view of _regvue_ and displays the documentation information about the different design elements.
It also includes the navigation menu and the header.

URLs for the element view start with `/root`.
Then to view a specific element, the element id is given in the form of a URL.
So to view an element with id `system.board.ctrl`, the URL would be `/root/system/board/ctrl`.

/ ElementView image /

The final page view is the 404 page.
This view is displayed when a user either enters a URL that does not correspond to a pre-defined route or tries to navigate to an element that does not exist.

/ PageNotFound image /

==== Data Store

_regvue_ uses Pinia, a store library specifically designed for use with Vue, to store and maintain all cross-component data that is used in the app.
Normally, data within Vue apps must be directly passed from parent components to child components, but having data that is accessible throughout the entire app can help simplify this data hierarchy.

When _regvue_ first loads, a Pinia store object is created.
When the user then opens an RDF file, the store object parses the raw JSON and generates a map that stores all hardware elements (i.e. registers, blocks, or memory segments) within the FPGA design as formatted TypeScript objects.

This greatly simplifies accessing information about different elements from the different components within the file.
Instead of passing information about all the different elements from every parent component to every child component, _regvue_ can instead obtain the current element's id from the URL, and then can use that id to access information about the element from the store object.

==== Includes

It is possible for FPGA designs to consist of multiple FPGA sub-designs that are grouped together due to related function or location.
An issue we encountered during development was the need to continually combine FPGA sub-designs for larger combined designs.
For example, the Europa Input/Output (EIO) and the Europa Memory Card (EMEM) FPGAs had both been specified using the RDF.
But the overall Europa Compute Element (ECE) contains both of these sub-designs.
Originally an external tool was used to combine the two sub-design RDF files into a single combined file.
This was not desireable because it meant an extra tool would need to be maintained and that there would duplicated information being stored.

To address this issue, we introduced the concept of an Include Element.
Rather than specifying an element as a register, block, or memory section, hardware design engineers can instead specify an element of type `include` and then provide a URL.
When _regvue_ loads the RDF file, it will attempt to fetch an RDF file from the given URL and insert it into the parent RDF file.

[source.json]
.Example `include` element
----
"ece.eio": {
    "name": "eio",
    "id": "ece.eio",
    "type": "include",
    "offset": "0xc0e00000",
    "url": "eio.json"
}
----

This drastically simplifies the process of building combined designs and removes the need for an external tool to combine RDF files.

==== Testing

Testing is incredibly important for ensuring previously implemented features continue to work.
Unit tests are typically used to test individual functions in isolation.
End-to-end tests or integration tests are used to test how an application functions when its different modules are integrated and working together.

_regvue_ uses the Vitest unit testing framework to test utility functions.
These tests provide an input and expected output to different isolated functions.
The testing framework will then call the given functions with the provided inputs and ensure it matches the provided outputs.

_regvue_ uses the Cypress end-to-end testing framework to perform browser-based integration testing.
These tests are more focused on testing the interactivity of the app, and often test multiple components at the same time.
These tests are written by accessing HTML DOM elements, typically by the elements' ids, and then performing actions on those elements, such as clicking or typing, by calling Cypress functions.

An example of an integration test that _regvue_ has includes typing a search term in the search box, selecting the first search result, and ensuring that the app then displays information about that search result.
Other Cypress tests written for _regvue_ include testing menu navigation, bit table value manipulation, and opening new RDF files.

=== Deployment

_regvue_ has minimal hosting requirements and can be deployed as a static site on almost any hosting platform such as Vercel, Netlify, or AWS.
The _regvue_ development team maintains a set of deployments using GitHub Pages that correspond to all major versions of _regvue_, meaning end users do not need to install or deploy _regvue_ if they do not wish to.

==== Restricted Information

Most information regarding FPGA designs at JPL is subject to U.S. Export Regulations.
This means that the information cannot be shared with foreign persons without prior approval. 
There are also additional sensitivity levels that require further restriction, such as Controlled Unclassified (CUI), Sensitive but Unclassified (SBU), or For Official Use Only (FOUO).

To allow for information that falls under these sensitivity levels to be usable with _regvue_, significant thought had to be given to ensure that users can only access information that they are authorized to. 
The _regvue_ application itself does not include any sensitive information within its deployed build code, so the problem that we had to solve was finding a way to ensure any RDF files that users want to link to are limited to those who are allowed to access them, but still accessible by the _regvue_ app.

Our use of GitHub Pages actually solved this issue for us with minimal overhead.
We host _regvue_ on JPL's GitHub Enterprise server using GitHub Pages, which is only accessible to U.S. persons and requires users to be logged in with a JPL GitHub account.
When users then want to access a RDF file by URL, if that file is also hosted in a public repository on JPL's GitHub Enterprise server, no additional authentication is necessary because they are already logged in with their JPL GitHub account.

Information that falls under stricter sensitivity levels must be restricted further.
To accomplish this, RDF files can be hosted in a private repository on JPL's GitHub Enterprise Server and then access can be granted to select individuals.
When users attempt to load a file from these private repositories, their JPL GitHub account will be checked to ensure they are allowed access.

This use of GitHub Enterprise therefore means the official _regvue_ deploy has built-in authentication with no additional code necessary.

==== Desktop Application

While _regvue_ was primarily developed to be deployed as a web app, we have also been able to create executable binaries that are capable of running directly on Windows, Mac, and Linux operating systems as a desktop application.
To accomplish this, we used the Tauri framework, which provides a Rust backend and a cross-platform WebView rendering library that is capable of displaying a web-based frontend.
While not officially supported yet, we plan to use these local executables in the future to add specific features to _regvue_ that would be otherwise impossible due to browser limitations.

== Results

Engineers working on the Europa Clipper and Mars Sample Return (MSR) missions have already integrated _regvue_ into their workflows, and so far the tool has proved to be a great help.

"I have used regvue a lot during integration testing for Europa Clipper.
There are integration tasks [where I have] to poke and peek at registers and the regvue tool allows me to quickly look up a register and test out different register values.
Figuring out those register values can be quite challenging since it is broken down to 32 bits, but the regvue tool helps make that translation easier.
It cuts down the time it would take to go through the document, put down on paper what the register should be and double checking the value.
Also, with the tool being able to convert from binary to decimal to hexadecimal, it makes translating engineering values way easier.
I hope to continue to use this on future projects such as MSR."
-- Brian Nguyen, Senior Electrical Engineer, Europa Clipper (348E) +

"Regvue is the interactive register viewer I have dreamed about for years.
It's a powerful tool to assist hardware designers, software designers, and end-users.
I plan to use it on all of my flight FPGA designs going forward"
-- Ryan Stern, MSR SRL Motor Control Card FPGA Task Lead (349C)

/ Talk more about how regvue has worked /

/ Talk about where does it fall short /

== Conclusion

Figures.
Include figures whenever possible to illustrate your points.
Explanatory diagrams may help explain background information (pictures from textbooks are fine).
Carefully choose your image size, font size, line widths, and labels to ensure that your figures are clear.
Plot theory and experiment on the same graph and redraw screen photos.
All figures should be accompanied by explanatory captions.

Favor fewer information packed screenshots that show multiple things at once.
Use annotations to point out relevant portions. (e.g. recent searches + search suggestions)
Consider creating an image that shows the link between the schema and the render (e.g.root.display_name and where it is rendered in the app)

== Acknowledgments

Special thanks to Rob Donnelly for his mentorship and guidance.
_regvue_ was his vision, and it has been an extremely rewarding experience helping to bring that vision to reality.

Thanks to Mike Thielman, Europa Clipper Avionics Systems Engineering Lead, and the Europa Clipper Mission for providing the funding and administrative support necessary to transform _regvue_ from a proposal and prototype to a full-fledged hardware documentation solution.

Additional thanks to Ryan Stern and the hardware engineers in the Flight Software and Avionics Systems Group for their early adoption of _regvue_ and for supporting its development by suggesting new features and identifying bugs.

And lastly, thanks to the Caltech Student-Faculty Programs Office and JPL for hosting the JPL Summer Internship Program and to all those who helped support this program.

== References

<add any references>