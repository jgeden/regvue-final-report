= Improving Hardware Register Documentation Tooling
Josh Geden <joshua.geden@duke.edu>; Rob Donnelly <robert.donnelly@jpl.nasa.gov>
:toc:
:imagesdir: images
:sectnums:
:toclevels: 3
// :titlepage:
// :doctype: book
// :chapter-label:
// :hardbreaks-option:

== Abstract

Hardware documentation at JPL has historically been generated by hand and accessed through shared PDF or Word documents.
This can lead to issues where the documentation does not keep pace with the actual hardware implementation.
It also leads to documents that are difficult to use and lack the necessary features to accelerate the hardware debugging process.
To address these issues, a hardware documentation tool called _regvue_ was created.
This tool is available as both a web and desktop application and is capable of building advanced documentation sites from data files that implement the Register Description Format.
Documentation can now be automatically updated by making changes to the data files, ensuring that engineers always have access to current information in an easy-to-read format.
Features such as full-text search and automatic bit encoding/decoding are also provided.
Future features will include enabling _regvue_ to interface with hardware and directly read and decode register values.
By providing higher quality documentation and advanced features with _regvue_, hardware engineers will spend significantly less time during the debugging process.


== Introduction

When engineers need to consult Field Programmable Gate Array (FPGA) hardware documentation, they traditionally have turned to PDF or Word documents created and maintained by FPGA design engineers that are hosted on internal file-sharing websites.
From these websites, FPGA hardware test engineers can either preview the document online or they can download the file and open it locally.
Because online file viewers lack certain features and are typically slower to use, most engineers download these documentation files and use them locally.

This creates an issue when the design engineer uploads a new version of the documentation but test engineers continue to use their locally-downloaded documentation file, which has since become outdated.
This mismatch can be difficult to notice and can incur significant delays, and therefore additional costs, during the FPGA testing and debugging process.

In addition to this, the documentation provided by these documents is static and does not support the actual testing and debugging workflow of hardware engineers.
For example, when testing or debugging hardware, FPGA hardware test engineers may read out the value of a specific hardware register.
The value may also be outputted as a hexadecimal value, but in order to understand the meaning of the value, it has to be converted to a binary or decimal representation.
Registers can also consist of numerous fields where the meaning of specific field values depends on the position of the field in the overall register.
The overall register value may also be read out as little or big endian value depending on the device under test.

So a typical workflow to understand the value of a certain field on a given register may look like:

. Read out the value of the register using external tools

. Because the register value is written out using as big-endian, the test engineer has to manually byte swap the value

. Because the field of interest only takes up a certain range of bits, manually convert the value from hexadecimal to binary

. Isolate the bits of interest and then convert back to hexadecimal

/ Use a graphic to summarize these steps instead of writing out like this /

This manual manipulation and conversion of register and field values is incredibly error-prone and unnecessarily increases the complexity of the already complex hardware testing and debugging process.

These issues with JPL's existing hardware documentation strategy is what inspired the development of _regvue_.
Available as both web and desktop applications, _regvue_ utilizes a design-agnostic JSON schema called the Register Description Format (RDF) to generate easy-to-use and modern documentation.
Design engineers can manually create RDF files or use existing register automation tools to generate RDF files from existing documentation specifications. 
_regvue_ can then parse these files to produce a website with all the features of classic online technical documentation sites as well as additional features specific to the FPGA testing and debugging workflow.
The documentation provided by _regvue_ significantly reduces the costs and delays associated with testing and debugging FPGA hardware.
FPGA hardware test engineers no longer have to worry about accessing out-of-date documentation, because FPGA design engineers can host their RDF files through online repositories that _regvue_ can access, so any update to the design can be automatically reflected in the documentation site accessed by test engineers.
Test engineers also no longer have to manually parse register values, because _regvue_ includes an interactive bit table for every register that can automatically decode register values into meaningful representations and can automatically convert values between hexadecimal, decimal, and binary representations.


/ IMAGE /

== Methods

This section details the different parts of the _regvue_ application and the surrounding technologies necessary to run and access it.

=== Schema

_regvue_ builds off of previous work that resulted in the creation of the Register Description Format (RDF) schema.
The RDF provides a design-agnostic JSON-encoded hardware design formalization that can be used to document FPGA hardware systems.

On different projects and missions, FPGA design engineers make use of different file formats and file types, such as Word DOCX files or Tcl files, when documenting their designs.
The RDF was created to bridge the gap between these different formats and file types and provide a general-use data format that can be used by external applications.
Different register automation solutions were then created that are capable of generating RDF files from the different hardware documentation types.

/ More differences here /

All RDF files begin as JSON-encoded files with three top-level objects.

The `schema` object defines the name and version of the schema being used.
_regvue_ currently only supports v1.x of the `register-description-format`, but this meta data was included to allow for future data formats to be supported in the future.
[source.json]
.Example `schema` object
----
"schema": {
    "version": "v1",
    "name": "register-description-format"
}
----

The `root` object provides information about the overall FPGA design being represented.
This includes the name, version, and descriptive doc text. 
It also includes a list of ids for all root-level elements (or root "children").
[source.json]
.Example `root` object
----
"root": {
    "version": "v1.0",
    "desc": "Example Design",
    "doc": "This is an example design.",
    "children": [ ... ],
}
----

The `elements` object is a map of all element within the system.
[source.json]
.Example `elements` object with a single `reg` type element
----
"elements": { 
    "registerA": {
        "id": "registerA",
        "name": "registerA",
        "type": "reg",
        "offset": "0x0",
        "doc": "Register A - an example register",
        "fields": [
            {
                "name": "example_field",
                "access": "ro",
                "lsb": 0,
                "nbits": 32,
                "doc": "Example field"
            }
        ]
    }
}
----

Versioning â€“ How do we make breaking changes to schema gracefully?

/ Talk about JSON schema and schema validation /

=== Application

When developing _regvue_, the two highest priority goals were interactivity and portability.
We first considered using existing technology to generate plain HTML pages, such as https://readthedocs.org/[_Read the Docs_], however this lacked the interactivity that we wanted users to have access to and would not allow for advanced features such as automatic register value parsing.
We also considered creating a desktop app with Python and the TK GUI library, however this would not be an incredibly portable solution, because users would have to download and install _regvue_ on any computer where they want to use it.
It also makes updating _regvue_ much more complex because users would be running local executables.

Based on the shortcomings of these implementations, we decided to create _regvue_ as a web application.
This allows us to include interactivity by using JavaScript within the app and it is incredibly portable because users can access it from any browser on any type of OS.

==== Frontend

The frontend of _regvue_ was built using the Vue JavaScript framework.
Vue provides a declarative and component-based programming model to efficiently develop user interfaces.

https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Introduction#why_do_frameworks_exist

Similar JavaScript frameworks, such as Angular or React, also could have been used to create _regvue_.
We made the decision to use Vue because of its use of native HTML template to build UIs (as compared to React's use of JSX) and because Vue follows a progressive development model (as compared to Angular's more opinionated MVC-based design).

We used Typescript instead of plain JavaScript to improve the maintainability of the code base.

We used npm as our package manager and Vite as our build tool.
/ Why Vite /

_regvue_ uses Tailwind CSS, a utility-first CSS framework, that provides composable CSS classes to functionally build modern styles.

==== Routing

_regvue_ uses Vue Router to handle URL navigation.
As a progressive framework, Vue allows developers to opt-in to different levels of complexity, and therefore does not provide a router out of the box, however adding Vue Router to an existing project is incredibly simple since it follows a plugin-style architecture.

When the app first loads, a router object is created that comes with a predefined set of routes to handle.
_regvue_ currently has three distinct page views that the router can display based on the URL.

The first page view that most users of _regvue_ will see is the open page.
This page corresponds to the `/open` URL and provides users with input boxes to load a RDF file from the local filesystem or from a URL.

/ OpenView image /

Once the user opens a RDF file, the element page is shown.
This is the main view of _regvue_ and displays the documentation information about the different design elements.
It also includes the navigation menu and the header.

/ Talk about url pattern here and how it corresponds to element id /

/ ElementView image /

The final page view is the 404 page.
This view is displayed when a user either enters a URL that does not correspond to a pre-defined route or tries to navigate to an element that does not exist.

/ PageNotFound image /

==== Data

_regvue_ uses Pinia, a store library specifically designed for use with Vue, to store and maintain all cross-component data that is used in the app.
Normally, data within Vue apps must be directly passed from parent components to child components, but having data that is accessible throughout the entire app can help simplify this data hierarchy.

When _regvue_ first loads, a Pinia store object is created.
When the user then opens an RDF file, the store object parses the raw JSON and generates a map that stores all hardware elements (i.e. registers, blocks, or memory segments) within the given FPGA design as formatted Typescript objects.
This greatly simplifies accessing information about different elements from the different components within the file.
Instead of passing information about all the different elements from every parent component to every child component, _regvue_ can instead obtain the current element's id from the URL, and then can use that id to access information about the element from the store object.

==== Testing

_regvue_ uses the Vitest unit testing framework to test utility functions and the Cypress end-to-end testing framework to perform browser-based integration testing.
These tests help ensure any changes to the code base do not break existing functionality. 

=== Hosting

_regvue_ can be hosted on almost any hosting platform, such as Vercel, Netlify, or even AWS.
The _regvue_ development team maintains a set of deployments using GitHub Pages that correspond to all major versions of _regvue_, meaning end users do not need to install or deploy _regvue_ if they do not wish to.

Because _regvue_ is being used by JPL engineers to document information that more often than not is subject to U.S. Export Regulations, significant thought had to be given to ensure that only authorized users can access export-controlled information.
The _regvue_ application itself does not include any export-controlled information within its source code, so the problem that we had to solve was finding a way to ensure any RDF files that users want to link to are limited to authenticated users but still accessible by the _regvue_ app.

Our use of GitHub Pages actually solved this issue for us with minimal difficulty.
Because we host _regvue_ on JPL's GitHub Enterprise server using GitHub Pages, which is only accessible for authenticated users connected to the JPL VPN, users must log in with their JPL credentials to access the official deploy.
When users then want to access a RDF file by URL, if that file is also hosted on JPL's GitHub Enterprise server, no additional authentication is necessary because the _regvue_ deploy and the RDF file share the same origin URL.
This use of GitHub Enterprise therefore means the official _regvue_ deploy has built-in authentication with no additional code necessary.

==== Executable Binaries

While _regvue_ was primarily developed to be a web-based tool, we have also been able to create executable binaries using the Tauri framework that are capable of running directly on Windows, Mac, and Linux operating systems.
While not officially supported yet, we plan to use these local executables to add specific features to _regvue_ that would be otherwise impossible to add to a browser-based application.

== Results

Engineers working on the Europa Clipper and Mars Sample Return (MSR) missions have already integrated _regvue_ into their workflows, and so far the tool has proved to be a great help.

"I have used regvue a lot during integration testing for Europa Clipper.
There are integration tasks [where I have] to poke and peek at registers and the regvue tool allows me to quickly look up a register and test out different register values.
Figuring out those register values can be quite challenging since it is broken down to 32 bits, but the regvue tool helps make that translation easier.
It cuts down the time it would take to go through the document, put down on paper what the register should be and double checking the value.
Also, with the tool being able to convert from binary to decimal to hexadecimal, it makes translating engineering values way easier.
I hope to continue to use this on future projects such as MSR."
-- Brian Nguyen, Senior Electrical Engineer, Europa Clipper (348E)

"Regvue is the interactive register viewer I have dreamed about for years.
It's a powerful tool to assist hardware designers, software designers, and end-users.
I plan to use it on all of my flight FPGA designs going forward"
-- Ryan Stern, MSR SRL Motor Control Card FPGA Task Lead (349C)

/ Talk more about how regvue has worked /
/ Talk about where does it fall short /

== Conclusion

Figures.
Include figures whenever possible to illustrate your points.
Explanatory diagrams may help explain background information (pictures from textbooks are fine).
Carefully choose your image size, font size, line widths, and labels to ensure that your figures are clear.
Plot theory and experiment on the same graph and redraw screen photos.
All figures should be accompanied by explanatory captions.

Favor fewer information packed screenshots that show multiple things at once.
Use annotations to point out relevant portions. (e.g. recent searches + search suggestions)
Consider creating an image that shows the link between the schema and the render (e.g.root.display_name and where it is rendered in the app)

== Acknowledgments

Acknowledge your mentor and all other individuals who provided technical assistance, and the individuals, organizations, grants, or contracts from whom you received financial support.
Students should be sure to include the names of their financial sponsors.

== References

Authors are responsible for the accuracy of references.
References should be numbered sequentially as they appear in the text and should be listed at the end of the paper.
Reference numbers should be in superscript when cited in the text.


== Appendix

Appendices.
Large data files, catalogs, tables, diagrams, and archival information may be included in 'Appendices' at the end of the paper.
