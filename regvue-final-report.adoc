= Improving Hardware Register Documentation Tooling
Josh Geden <joshua.geden@duke.edu>; Rob Donnelly <robert.donnelly@jpl.nasa.gov>
:toc:
:imagesdir: images
:sectnums:
:toclevels: 3
// :titlepage:
// :doctype: book
// :chapter-label:
// :hardbreaks-option:

== Abstract

Hardware documentation at JPL has historically been generated by hand and accessed through shared PDF or Word documents.
This can lead to issues where the documentation does not keep pace with the actual hardware implementation.
It also leads to documents that are difficult to use and lack the necessary features to accelerate the hardware debugging process.
To address these issues, a hardware documentation tool called _regvue_ was created.
This tool is available as both a web and desktop application and is capable of building advanced documentation sites from data files that implement the Register Description Format.
Documentation can now be automatically updated by making changes to the data files, ensuring that engineers always have access to current information in an easy-to-read format.
Features such as full-text search and automatic bit encoding/decoding are also provided.
Future features will include enabling _regvue_ to interface with hardware and directly read and decode register values.
By providing higher quality documentation and advanced features with _regvue_, hardware engineers will spend significantly less time during the debugging process.


== Introduction

When engineers need to consult Field Programmable Gate Array (FPGA) hardware documentation, they traditionally have turned to PDF or Word documents created and maintained by FPGA design engineers that are hosted on internal file-sharing websites.
From these websites, FPGA hardware test engineers can either preview the document online or they can download the file and open it locally.
Because online file viewers lack certain features and are typically slower to use, most engineers download these documentation files and use them locally.

This creates an issue when the design engineer uploads a new version of the documentation but test engineers continue to use their locally-downloaded documentation file, which has since become outdated.
This mismatch can be difficult to notice and can incur significant delays, and therefore additional costs, during the FPGA testing and debugging process.

The documentation provided by these documents is also static and does not support the actual testing and debugging workflow of hardware engineers.
For example, when testing or debugging hardware, FPGA hardware test engineers are often interested in the specific value of certain hardware registers.
These registers may consist of numerous fields where the meaning of specific field values depends on the position of the field in the overall register.
The overall register value may also be read out as little or big endian value depending of the device under test (DUT).
The value may also be outputted as a hexadecimal value, but in order to understand the meaning of the value, it has to be converted to a binary or decimal representation.
This manual manipulation and conversion of field values is incredibly error-prone and unnecessarily increases the complexity of the already complex hardware testing and debugging process.

These issues with JPL's existing hardware documentation strategy is what inspired the development of _regvue_.
Available as both web and desktop applications, _regvue_ utilizes a design-agnostic JSON schema called the Register Description Format (RDF) to generate easy-to-use and modern documentation websites.
Design engineers can create RDF files and then _regvue_ can parse these files to produce a full website with all the features of classic online technical documentation sites.
The documentation provided by _regvue_ significantly reduces the costs and delays associated with testing and debugging FPGA hardware.
FPGA hardware test engineers no longer have to worry about accessing out-of-date documentation, because FPGA design engineers can host their RDF files through online repositories that _regvue_ can access, so any update to the design can be automatically reflected in the website created by _regvue_.
Test engineers also no longer have to manually parse register values, because _regvue_ includes an interactive bit table for every register that can automatically decode register values into meaningful representations and can automatically convert values between hexadecimal, decimal, and binary representations.


/ IMAGE /

== Methods

This section details the different parts of the _regvue_ application and the surrounding technologies necessary to run and access it.

=== Schema

_regvue_ builds off of previous work that resulted in the creation of the Register Description Format (RDF) schema.
The RDF provides a design-agnostic JSON-encoded hardware design formalization that can be used to document FPGA hardware systems.

On different projects and missions, FPGA design engineers make use of different file formats and file types, such as Word DOCX files or Tcl files, when documenting their designs.
The RDF was created to bridge the gap between these different formats and file types and provide a general-use data format that can be used for external applications.
Different register automation solutions were then created that are capable of generating RDF files from the different hardware documentation types.

The RDF was inspired in part by the https://www.keil.com/pack/doc/CMSIS/SVD/html/index.html[CMSIS System View Description format] (CMSIS-SVD).
CMSIS-SVD files are specified using an XML-based format, and also includes * more features that make it different *.
RDF files are instead specified as JSON files in order to more easily support a web-based application.

/ More differences here /

All RDF files begin with three top-level objects.

The `schema` object defines the name and version of the schema being used.
_regvue_ currently only supports v1.x of the `register-description-format`, but this meta data was included to allow for future data formats to be supported in the future.
[source.json]
.Example `schema` object
----
"schema": {
    "version": "v1",
    "name": "register-description-format"
}
----

The `root` object provides information about the overall FPGA design being represented.
This includes the name, version, and descriptive doc text. 
It also includes a list of ids for all root-level elements (or root "children").
[source.json]
.Example `root` object
----
"root": {
    "version": "v1.0",
    "desc": "Example Design",
    "doc": "This is an example design.",
    "children": [ ... ],
}
----

The `elements` object is a map of all element within the system.
[source.json]
.Example `elements` object with a single `reg` type element
----
"elements": { 
    "registerA": {
        "id": "registerA",
        "name": "registerA",
        "type": "reg",
        "offset": "0x0",
        "doc": "Register A - an example register",
        "fields": [
            {
                "name": "example_field",
                "access": "ro",
                "lsb": 0,
                "nbits": 32,
                "doc": "Example field"
            }
        ]
    }
}
----

Versioning â€“ How do we make breaking changes to schema gracefully?

/ JSON schema /

=== Application

When developing _regvue_, the two highest priority goals were interactivity and portability.
We first considered using existing technology to generate plain HTML pages, such as https://readthedocs.org/[_Read the Docs_], however this lacked the interactivity that we wanted users to have access to.
We also considered creating a desktop app with Python and the TK GUI library, however this would not be an incredibly portable solution, because users would have to download and install _regvue_ on any computer where they want to use it.
It also makes updating _regvue_ much more complex because users would be running local executables.

Based on the shortcomings of these implementations, we decided to create _regvue_ as a web application.
This allows us to include interactivity by using JavaScript within the app and it is incredibly portable because users can access it from any browser on any type of OS.

Vite, Typescript, npm, 

==== Frontend

The frontend of _regvue_ was built using the Vue JavaScript framework.
Vue provides a declarative and component-based programming model to efficiently develop user interfaces.

https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Introduction#why_do_frameworks_exist

Similar JavaScript frameworks, such as Angular or React, also could have been used to create _regvue_.
We made the decision to use Vue because of its use of native HTML template to build UIs (as compared to React's use of JSX) and because Vue follows a progressive development model (as compared to Angular's more opinionated MVC-based design).

_regvue_ uses Tailwind CSS, a utility-first CSS framework, that provides composable CSS classes to functionally build modern styles.

==== Routing

_regvue_ uses Vue Router to handle URL navigation.
As a progressive framework, Vue allows developers to opt-in to different levels of complexity, and therefore does not provide a router out of the box, however adding Vue Router to an existing project is incredibly simple since it follows a plugin-style architecture.

When the app first loads, a router object is created that comes with a predefined set of routes to handle.
_regvue_ currently has three distinct page views that the router can display based on the URL.

The first page view that most users of _regvue_ will see is the open page.
This page corresponds to the `/open` URL and provides users with input boxes to load a RDF file from the local filesystem or from a URL.

/ OpenView image /

Once the user opens a RDF file, the element page is shown.
This is the main view of _regvue_ and displays the documentation information about the different design elements.
It also includes the navigation menu and the header.

/ Talk about url pattern here and how it corresponds to element id /

/ ElementView image /

The final page view is the 404 page.
This view is displayed when a user either enters a URL that does not correspond to a pre-defined route or tries to navigate to an element that does not exist.

/ PageNotFound image /

==== Data

_regvue_ uses Pinia, a store library specfiically designed for use with Vue, to store and maintain all cross-component data that is used in the app.
Normally, data within Vue apps must be directly passed from parent components to child components, but having data that is accessible throughout the entire app can help simplify this data hierarchy.

When _regvue_ first loads, a Pinia store object is created.
When the user then opens an RDF file, the store object parses the raw JSON and generates a map that stores all hardware elements (i.e. registers, blocks, or memory segments) within the given FPGA design as formatted Typescript objects.
This greatly simplifies accessing information about different elements from the different components within the file.
Instead of passing information about all the different elements from every parent component to every child component, _regvue_ can instead obtain the current element's id from the URL, and then can use that id to access information about the element from the store object.

==== Testing

_regvue_ uses the Vitest unit testing framework to test utility functions and the Cypress end-to-end testing framework to perform browser-based integration testing.

=== Hosting

Describe the use of GitHub Pages

=== Executable Binaries

/ Tauri /

== Results

Engineers working on the Europa Clipper and Mars Sample Return (MSR) missions have already integrated _regvue_ into their workflows, and so far the tool has proved to be a great help.

"I have used regvue a lot during integration testing for Europa Clipper.
There are integration tasks [where I have] to poke and peek at registers and the regvue tool allows me to quickly look up a register and test out different register values.
Figuring out those register values can be quite challenging since it is broken down to 32 bits, but the regvue tool helps make that translation easier.
It cuts down the time it would take to go through the document, put down on paper what the register should be and double checking the value.
Also, with the tool being able to convert from binary to decimal to hexadecimal, it makes translating engineering values way easier.
I hope to continue to use this on future projects such as MSR."
-- Brian Nguyen, Senior Electrical Engineer, Europa Clipper (348E)

"Regvue is the interactive register viewer I have dreamed about for years.  It's a powerful tool to assist hardware designers, software designers, and end-users.  I plan to use it on all of my flight FPGA designs going forward"
-- Ryan Stern, MSR SRL Motor Control Card FPGA Task Lead (349C)

* What do people think about it
* Has it made development easier
* Where does it fall short

== Conclusion

Figures.
Include figures whenever possible to illustrate your points.
Explanatory diagrams may help explain background information (pictures from textbooks are fine).
Carefully choose your image size, font size, line widths, and labels to ensure that your figures are clear.
Plot theory and experiment on the same graph and redraw screen photos.
All figures should be accompanied by explanatory captions.

Favor fewer information packed screenshots that show multiple things at once.
Use annotations to point out relevant portions. (e.g. recent searches + search suggestions)
Consider creating an image that shows the link between the schema and the render (e.g.root.display_name and where it is rendered in the app)

== Acknowledgments

Acknowledge your mentor and all other individuals who provided technical assistance, and the individuals, organizations, grants, or contracts from whom you received financial support.
Students should be sure to include the names of their financial sponsors.

== References

Authors are responsible for the accuracy of references.
References should be numbered sequentially as they appear in the text and should be listed at the end of the paper.
Reference numbers should be in superscript when cited in the text.


== Appendix

Appendices.
Large data files, catalogs, tables, diagrams, and archival information may be included in 'Appendices' at the end of the paper.
